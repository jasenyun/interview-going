# 【准备面试｜算法】十大排序算法

## 前言

现在算法面试，是很多公司面试的第一道门槛。排序算法就是对一序列对象根据某关键字进行排序。算法的好坏主要根据时间复杂度和空间复杂度来决定。本文主要介绍常见的十大排序算法：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、计数排序、基数排序、桶排序、堆排序。将主要讲述比较常见的几个排序算法。

## 基本排序

### 冒泡排序

#### 基本思路

像水泡一样，越到水面气泡越大。主要通过不断的比较相邻的元素。如果第一个比第二个大就交换它们。每一对相邻元素都做相同的工作，这样就会将最大交换到最后。

通过使用 2个循环，第一个循环控制轮次，第二个循环控制相邻元素的比较。因是两个互相比较所以循环控制到倒数第二个即可。

#### 代码示例

```go
func Bubble() []int {
    var arr []int = []int{3, 44, 38, 5, 47, 15, 2, 26, 27}
    // 临界 如果数组少于等于 1个，则只需要比较直接返回
    if len(arr) > 1 {
        // 外层控制轮次
        for i := 0; i < len(arr)-1; i++ {
            // 内层进行相邻元素比较
            for j := 0; j < len(arr)-1-i; j++ {
                if arr[j] > arr[j+1] {
                    arr[j], arr[j+1] = arr[j+1], arr[j]
                }
            }
        }
    }
    return arr
}
```

### 插入排序

#### 基本思路

将已排序好的数据插入到排好序的部分。

使用嵌套循环，第一层循环，是待排序的元素要与第二层里已排序好的所有元素进行对比。初始第一个元素当作是已排好序。

3, 44, 38, 5, 47, 15, 2, 26, 27

第一轮：3为已排好序，44待排序，44>3 保持不变[3, 44, 38, 5, 47, 15, 2, 26, 27]

第二轮：3，44 为已排好序，38待排序，38分别和[3,44]比较，得到结果 [3,38,44,5, 47, 15, 2, 26, 27]

依次循环下去

#### 代码示例

```go
func InsertSort() []int {
    var arr []int = []int{3, 44, 38, 5, 47, 15, 2, 26, 27}
    for i := 1; i < len(arr); i++ {
        cur := arr[i] // 待排序的值
        var j int
        // 第二层循环，就是前面已排好序的进行比较
        for j = i - 1; j >= 0 && arr[j] > cur; j-- {
            arr[j+1] = arr[j]

        }
        //第二层循环结束时，j+1 的位置就是 cur 要插入的位置
        arr[j+1] = cur
    }
    return arr
}
```

## 常考排序

十大基础算法中，有三个算法可能经常会在面试中遇到：归并排序、快速排序、拓扑排序。它们的核心思想都是分而治。将复杂问题简单化去解决。

### 合并排序(归并排序)

#### 基本思路

核心就是分而治之，将一个复杂问题拆解成两个或多个相似的子问题，然后再继续拆解成更小的子问题，直接拆解成可以简单求解的问题进行解决，最后再合并。

归并排序，先划分成2个子数组，再对每个子数组划分成更小的数组，直到子数组只有一个元素再开始排序

[3, 44, 38, 5, 47, 15, 2, 26, 27]

[3, 44, 38, 5 ,47 ] [15, 2, 26, 27]

[3,44,38] [5,47] [15,2] [26, 27]

[3,44] [38] [5] [47] [15] [2] [26][27]

 [3] [44]    

merge

[3, 44] [38] [5] [47]. [15] [2][26][27]

[3,38,44] [5,47] [2,15] [26,27]

。。。                           

#### 代码示例

```go
func sort(arr []int, left int, right int) {
    if left >= right { // 只剩下最后一个元素则直接返回
        return
    }
    mid := left + (right-left)/2
    sort(arr, left, mid)
    sort(arr, mid+1, right)

    // 排好序后进行组合
    merge(arr, left, mid, right)
}
func merge(arr []int, left int, mid int, right int) {
    tempArr := arr
    k := left
    i := left
    j := mid + 1

    for {
        if i > mid {
            k += 1
            j += 1
            arr[k] = tempArr[j]
        } else if j > right {
            k += 1
            i += 1
            arr[k] = tempArr[i]
        } else if tempArr[j] < tempArr[i] {
            k += 1
            j += 1
            arr[k] = tempArr[j]
        } else {
            k += 1
            i += 1
            arr[k] = tempArr[i]
        }
        if k <= right {
            break
        }
    }
}
```

### 快速排序

#### 基本思路

快速排序也是采用分治的思想。

- 先将数组划分成较小和较大的两个子数组

- 随机从数组中选择一个数作为基准值，

#### 代码示例

## 其他排序
